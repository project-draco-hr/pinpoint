{
  final List<SpanBo> root=new ArrayList<SpanBo>();
  for (  SpanBo span : spans) {
    if (span.getParentSpanId() == ROOT) {
      root.add(span);
    }
  }
  final int matchSize=root.size();
  if (matchSize == 1) {
    final SpanBo spanBo=root.get(0);
    logger.debug("root span found best match:{}",spanBo);
    matchType=BEST_MATCH;
    return spanBo.getSpanId();
  }
  if (matchSize > 1) {
    logger.warn("parentSpanId(-1) collision. size:{} root span:{} allSpan:{}",matchSize,root,spans);
    throw new IllegalStateException("parentSpanId(-1) collision. size:" + matchSize);
  }
  final List<SpanBo> collectorAcceptTimeMatcher=new ArrayList<SpanBo>();
  for (  SpanBo span : spans) {
    if (span.getCollectorAcceptTime() == collectorAcceptTime) {
      collectorAcceptTimeMatcher.add(span);
    }
  }
  final int startMatchSize=collectorAcceptTimeMatcher.size();
  if (startMatchSize == 1) {
    final SpanBo spanBo=collectorAcceptTimeMatcher.get(0);
    logger.info("collectorAcceptTime span found startTime match:{}",spanBo);
    matchType=START_TIME_MATCH;
    return spanBo.getSpanId();
  }
  if (startMatchSize > 1) {
    logger.warn("collectorAcceptTime match collision. size:{} collectorAcceptTime:{} allSpan:{}",startMatchSize,collectorAcceptTime,spans);
    throw new IllegalStateException("startTime match collision size:" + startMatchSize + " collectorAcceptTime:"+ collectorAcceptTime);
  }
  logger.warn("collectorAcceptTime match not found. size:{} collectorAcceptTime:{} allSpan:{}",startMatchSize,collectorAcceptTime,spans);
  throw new IllegalStateException("startTime match not found startTime size:" + startMatchSize + " collectorAcceptTime:"+ collectorAcceptTime);
}
