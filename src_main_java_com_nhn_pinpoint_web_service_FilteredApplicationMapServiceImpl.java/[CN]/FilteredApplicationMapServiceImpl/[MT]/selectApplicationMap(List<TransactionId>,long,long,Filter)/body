{
  StopWatch watch=new StopWatch();
  watch.start();
  Collection<TransactionId> filterdList=recursiveCallFilter(transactionIdList);
  List<List<SpanBo>> transactionList=this.traceDao.selectAllSpans(filterdList);
  Set<TransactionFlowStatistics> statisticsData=new HashSet<TransactionFlowStatistics>();
  Map<String,TransactionFlowStatistics> statisticsMap=new HashMap<String,TransactionFlowStatistics>();
  Map<Long,SpanBo> transactionSpanMap=new HashMap<Long,SpanBo>();
  TimeseriesResponses tr=new TimeseriesResponses(from,to);
  for (  List<SpanBo> transaction : transactionList) {
    if (!filter.include(transaction)) {
      continue;
    }
    transactionSpanMap.clear();
    for (    SpanBo span : transaction) {
      transactionSpanMap.put(span.getSpanId(),span);
    }
    for (    SpanBo span : transaction) {
      String src, dest;
      ServiceType srcServiceType, destServiceType;
      SpanBo parentSpan=transactionSpanMap.get(span.getParentSpanId());
      if (span.isRoot() || parentSpan == null) {
        src=span.getApplicationId();
        srcServiceType=ServiceType.CLIENT;
      }
 else {
        src=parentSpan.getApplicationId();
        srcServiceType=parentSpan.getServiceType();
      }
      dest=span.getApplicationId();
      destServiceType=span.getServiceType();
      if (!destServiceType.isRecordStatistics() || destServiceType.isRpcClient()) {
        continue;
      }
      String statId=TransactionFlowStatisticsUtils.makeId(src,srcServiceType,dest,destServiceType);
      TransactionFlowStatistics stat=(statisticsMap.containsKey(statId) ? statisticsMap.get(statId) : new TransactionFlowStatistics(src,srcServiceType,dest,destServiceType));
      int slot;
      if (span.hasException()) {
        slot=Histogram.ERROR_SLOT.getSlotTime();
      }
 else {
        slot=destServiceType.getHistogram().findHistogramSlot(span.getElapsed()).getSlotTime();
      }
      stat.addSample(dest,destServiceType.getCode(),(short)slot,1);
      statisticsData.add(stat);
      statisticsMap.put(statId,stat);
      tr.add(statId,span.getCollectorAcceptTime(),span.getElapsed(),1L);
      tr.add(span.getApplicationId(),span.getCollectorAcceptTime(),span.getElapsed(),1L);
      List<SpanEventBo> spanEventBoList=span.getSpanEventBoList();
      if (spanEventBoList == null || spanEventBoList.isEmpty()) {
        continue;
      }
      src=span.getApplicationId();
      srcServiceType=span.getServiceType();
      for (      SpanEventBo spanEvent : spanEventBoList) {
        dest=spanEvent.getDestinationId();
        destServiceType=spanEvent.getServiceType();
        if (!destServiceType.isRecordStatistics()) {
          continue;
        }
        if (destServiceType.isRpcClient()) {
          if (transactionSpanMap.containsKey(spanEvent.getNextSpanId())) {
            continue;
          }
 else {
            destServiceType=ServiceType.UNKNOWN_CLOUD;
          }
        }
        String statId2=TransactionFlowStatisticsUtils.makeId(src,srcServiceType,dest,destServiceType);
        TransactionFlowStatistics stat2=(statisticsMap.containsKey(statId2) ? statisticsMap.get(statId2) : new TransactionFlowStatistics(src,srcServiceType,dest,destServiceType));
        int slot2;
        if (spanEvent.hasException()) {
          slot2=Histogram.ERROR_SLOT.getSlotTime();
        }
 else {
          slot2=destServiceType.getHistogram().findHistogramSlot(spanEvent.getEndElapsed()).getSlotTime();
        }
        stat2.addSample(spanEvent.getEndPoint(),destServiceType.getCode(),(short)slot2,1);
        statisticsData.add(stat2);
        statisticsMap.put(statId2,stat2);
        tr.add(statId2,span.getStartTime() + spanEvent.getStartElapsed(),spanEvent.getEndElapsed(),1L);
        tr.add(spanEvent.getDestinationId(),span.getCollectorAcceptTime(),span.getElapsed(),1L);
      }
    }
  }
  for (  TransactionFlowStatistics stat : statisticsData) {
    fillAdditionalInfo(stat);
  }
  ApplicationMap map=new ApplicationMap(statisticsData).build();
  map.setTimeseriesResponse(tr);
  watch.stop();
  logger.debug("Select filtered application map elapsed. {}ms",watch.getTotalTimeMillis());
  return map;
}
