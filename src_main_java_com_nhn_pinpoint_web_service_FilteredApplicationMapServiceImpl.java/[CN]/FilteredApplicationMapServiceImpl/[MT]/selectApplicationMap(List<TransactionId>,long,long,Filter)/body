{
  if (transactionIdList == null) {
    throw new NullPointerException("transactionIdList must not be null");
  }
  if (filter == null) {
    throw new NullPointerException("filter must not be null");
  }
  StopWatch watch=new StopWatch();
  watch.start();
  final Collection<TransactionId> recursiveFilterList=recursiveCallFilter(transactionIdList);
  final List<List<SpanBo>> originalList=this.traceDao.selectAllSpans(recursiveFilterList);
  final List<List<SpanBo>> filterList=filterList2(originalList,filter);
  Set<TransactionFlowStatistics> statisticsData=new HashSet<TransactionFlowStatistics>();
  Map<NodeId,TransactionFlowStatistics> statisticsMap=new HashMap<NodeId,TransactionFlowStatistics>();
  final TimeSeriesStore timeSeriesStore=new TimeSeriesStoreImpl2(from,to);
  for (  List<SpanBo> transaction : filterList) {
    final Map<Long,SpanBo> transactionSpanMap=new HashMap<Long,SpanBo>(transactionIdList.size());
    for (    SpanBo span : transaction) {
      final SpanBo old=transactionSpanMap.put(span.getSpanId(),span);
      logger.warn("duplicated span found:{}",old);
    }
    for (    SpanBo span : transaction) {
      final Node srcNode=createNode(span,transactionSpanMap);
      final Node destNode=new Node(span.getApplicationId(),span.getServiceType());
      if (destNode.isLink()) {
        continue;
      }
      final ComplexNodeId statId=new ComplexNodeId(srcNode,destNode);
      TransactionFlowStatistics stat;
      if (statisticsMap.containsKey(statId)) {
        stat=statisticsMap.get(statId);
      }
 else {
        stat=new TransactionFlowStatistics(srcNode.getName(),srcNode.getServiceType(),destNode.getName(),destNode.getServiceType());
      }
      final int slot=getHistogramSlot(span,destNode.getServiceType());
      stat.addSample(destNode.getName(),destNode.getServiceType().getCode(),(short)slot,1);
      statisticsData.add(stat);
      statisticsMap.put(statId,stat);
      timeSeriesStore.add(statId,span.getCollectorAcceptTime(),slot,1L,span.hasException());
      NodeId key=new ComplexNodeId(Node.EMPTY,new Node(span.getApplicationId(),span.getServiceType()));
      timeSeriesStore.add(key,span.getCollectorAcceptTime(),slot,1L,span.hasException());
      addNodeFromSpanEvent(statisticsData,statisticsMap,timeSeriesStore,transactionSpanMap,span);
    }
  }
  for (  TransactionFlowStatistics stat : statisticsData) {
    fillAdditionalInfo(stat);
  }
  ApplicationMap map=new ApplicationMap(statisticsData).build();
  map.setTimeSeriesStore(timeSeriesStore);
  watch.stop();
  logger.debug("Select filtered application map elapsed. {}ms",watch.getTotalTimeMillis());
  return map;
}
