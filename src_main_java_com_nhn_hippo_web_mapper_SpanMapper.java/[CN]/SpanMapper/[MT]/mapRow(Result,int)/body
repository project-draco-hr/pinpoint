{
  byte[] rowKey=result.getRow();
  if (rowKey == null) {
    return Collections.emptyList();
  }
  long most=BytesUtils.bytesToFirstLong(rowKey);
  long least=BytesUtils.bytesToSecondLong(rowKey);
  KeyValue[] keyList=result.raw();
  List<SpanBo> spanList=new ArrayList<SpanBo>();
  Map<Integer,SpanBo> spanMap=new HashMap<Integer,SpanBo>();
  List<SubSpanBo> subSpanBoList=new ArrayList<SubSpanBo>();
  for (  KeyValue kv : keyList) {
    if (kv.getFamilyLength() == HBaseTables.TRACES_CF_SPAN.length) {
      SpanBo spanBo=new SpanBo();
      spanBo.setMostTraceId(most);
      spanBo.setLeastTraceId(least);
      spanBo.setServerAcceptedTime(kv.getTimestamp());
      spanBo.setSpanID(Bytes.toInt(kv.getBuffer(),kv.getQualifierOffset()));
      spanBo.readValue(kv.getBuffer(),kv.getValueOffset());
      if (logger.isDebugEnabled()) {
        logger.debug("read span :{}",spanBo);
      }
      spanList.add(spanBo);
      spanMap.put(spanBo.getSpanId(),spanBo);
    }
 else     if (kv.getFamilyLength() == HBaseTables.TRACES_CF_TERMINALSPAN.length) {
      SubSpanBo subSpanBo=new SubSpanBo();
      subSpanBo.setMostTraceId(most);
      subSpanBo.setLeastTraceId(least);
      int spanId=Bytes.toInt(kv.getBuffer(),kv.getQualifierOffset());
      int spanIdOffset=4;
      short sequence=Bytes.toShort(kv.getBuffer(),kv.getQualifierOffset() + spanIdOffset);
      subSpanBo.setSpanId(spanId);
      subSpanBo.setSequence(sequence);
      subSpanBo.readValue(kv.getBuffer(),kv.getValueOffset());
      if (logger.isDebugEnabled()) {
        logger.debug("read subSpan :{}",subSpanBo);
      }
      subSpanBoList.add(subSpanBo);
    }
  }
  for (  SubSpanBo subSpanBo : subSpanBoList) {
    SpanBo spanBo=spanMap.get(subSpanBo.getSpanId());
    if (spanBo != null) {
      spanBo.addSubSpan(subSpanBo);
    }
  }
  if (annotationMapper != null) {
    Map<Integer,List<AnnotationBo>> annotationMap=annotationMapper.mapRow(result,rowNum);
    addAnnotation(spanList,annotationMap);
  }
  return spanList;
}
