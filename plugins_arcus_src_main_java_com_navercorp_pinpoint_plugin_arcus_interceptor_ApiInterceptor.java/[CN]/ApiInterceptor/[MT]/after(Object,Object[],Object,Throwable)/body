{
  if (isDebug) {
    logger.afterInterceptor(target,args,result,throwable);
  }
  final Trace trace=traceContext.currentTraceObject();
  if (trace == null) {
    return;
  }
  try {
    final CallStackFrame frame=trace.currentCallStackFrame();
    if (traceKey) {
      final Object recordObject=args[keyIndex];
      frame.recordApi(methodDescriptor,recordObject,keyIndex);
    }
 else {
      frame.recordApi(methodDescriptor);
    }
    frame.recordException(throwable);
    if (result instanceof Future && operationAccessor.isApplicable(result)) {
      Operation op=operationAccessor.get(result);
      if (op != null) {
        MemcachedNode handlingNode=op.getHandlingNode();
        SocketAddress socketAddress=handlingNode.getSocketAddress();
        if (socketAddress instanceof InetSocketAddress) {
          InetSocketAddress address=(InetSocketAddress)socketAddress;
          frame.recordEndPoint(address.getHostName() + ":" + address.getPort());
        }
      }
 else {
        logger.info("operation not found");
      }
    }
    if (serviceCodeAccessor.isApplicable(target)) {
      String serviceCode=serviceCodeAccessor.get(target);
      if (serviceCode != null) {
        frame.recordDestinationId(serviceCode);
        frame.recordServiceType(ARCUS);
      }
 else {
        frame.recordDestinationId("MEMCACHED");
        frame.recordServiceType(ServiceType.MEMCACHED);
      }
    }
 else {
      frame.recordDestinationId("MEMCACHED");
      frame.recordServiceType(ServiceType.MEMCACHED);
    }
    try {
      if (isAsynchronousInvocation(target,args,result,throwable)) {
        this.traceContext.getAsyncId();
        final AsyncTraceId asyncTraceId=trace.getAsyncTraceId();
        frame.recordNextAsyncId(asyncTraceId.getAsyncId());
        asyncTraceIdAccessor.set(result,asyncTraceId);
        if (isDebug) {
          logger.debug("Set asyncTraceId metadata {}",asyncTraceId);
        }
      }
    }
 catch (    Throwable t) {
      logger.warn("Failed to before process. {}",t.getMessage(),t);
    }
    frame.markAfterTime();
  }
 catch (  Throwable th) {
    if (logger.isWarnEnabled()) {
      logger.warn("after error. Caused:{}",th.getMessage(),th);
    }
  }
 finally {
    trace.traceBlockEnd();
  }
}
