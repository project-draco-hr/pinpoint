{
  SpanAlign root=makeSpanAlign(START_TIME,240);
  CallTree callTree=new SpanCallTree(root);
  callTree.add(1,makeSpanAlign(root.getSpanBo(),SYNC,(short)0,1,1));
  callTree.add(2,makeSpanAlign(root.getSpanBo(),SYNC,(short)1,2,1));
  callTree.add(3,makeSpanAlign(root.getSpanBo(),SYNC,(short)2,3,1));
  callTree.add(4,makeSpanAlign(root.getSpanBo(),SYNC,(short)3,4,1,-1,1));
  SpanAlign rpc=makeSpanAlign(START_TIME + 10,240);
  CallTree rpcTree=new SpanCallTree(rpc);
  rpcTree.add(1,makeSpanAlign(rpc.getSpanBo(),SYNC,(short)0,1,1));
  rpcTree.add(2,makeSpanAlign(rpc.getSpanBo(),SYNC,(short)1,2,1));
  rpcTree.add(3,makeSpanAlign(rpc.getSpanBo(),SYNC,(short)2,3,1));
  rpcTree.add(4,makeSpanAlign(rpc.getSpanBo(),SYNC,(short)3,4,1));
  callTree.add(rpcTree);
  CallTree asyncTree=new SpanAsyncCallTree(root);
  asyncTree.add(1,makeSpanAlign(root.getSpanBo(),ASYNC,(short)0,5,1,1,-1));
  asyncTree.add(2,makeSpanAlign(root.getSpanBo(),ASYNC,(short)1,6,1,1,-1));
  asyncTree.add(3,makeSpanAlign(root.getSpanBo(),ASYNC,(short)2,7,1,1,-1));
  asyncTree.add(4,makeSpanAlign(root.getSpanBo(),ASYNC,(short)3,8,1,1,-1));
  callTree.add(asyncTree);
  callTree.add(5,makeSpanAlign(root.getSpanBo(),SYNC,(short)4,5,1));
  callTree.add(2,makeSpanAlign(root.getSpanBo(),SYNC,(short)5,6,1));
  callTree.add(3,makeSpanAlign(root.getSpanBo(),SYNC,(short)6,7,1));
  callTree.add(-1,makeSpanAlign(root.getSpanBo(),SYNC,(short)7,8,1));
  callTree.add(1,makeSpanAlign(root.getSpanBo(),SYNC,(short)8,9,1));
  CallTreeIterator iterator=callTree.iterator();
  System.out.println("gapComplex");
  while (iterator.hasNext()) {
    CallTreeNode node=iterator.next();
    SpanAlign align=node.getValue();
    for (int i=0; i <= align.getDepth(); i++) {
      System.out.print("#");
    }
    System.out.println(" : gap=" + align.getGap());
    if (!node.isRoot()) {
      assertEquals(1,align.getGap());
    }
  }
}
